--- 
# ansible playbook to bootstrap cloudshell on ubuntu 22.04
# the stage1 playbook runs with the root user and sets things up for the connor user later

- name: 'bootstrap cloudshell (stage 1)'
  hosts: cloudshell_stage1
  remote_user: root
  vars_files:
    #- host_vars/cloudshell/vars.yml # placeholder
    - host_vars/cloudshell/secret.yml
    - host_vars/cloudshell/packages.yml

  pre_tasks: # pre_tasks will run before the roles. important because roles depend on packages and hostname

  - name: Set hostname
    ansible.builtin.hostname:
      name: csh

  - name: Update packages
    apt:
      update_cache: yes
      upgrade: full
      autoremove: true

  - name: create 'connor' user
    ansible.builtin.user:
      name: connor
      password: "{{ csh_user_password }}"
      shell: /bin/bash
      groups: sudo # add new groups like group1,group2,etc
      append: true

  - name: install packages
    package:
      name: "{{ install_packages }}"
      state: latest

  - name: install yadm
    get_url:
      url: https://github.com/TheLocehiliosan/yadm/raw/master/yadm
      dest: /usr/local/bin/yadm
      mode: '0755'

  roles:
    - role: geerlingguy.docker
      vars:
        # these options ensure you can use `docker compose`
        docker_install_compose_plugin: true
        docker_compose_package: docker-compose-plugin
        docker_compose_package_state: present
        docker_users:
          - connor # handles adding connor to the docker group
        # note: must use `su - connor` or reboot to have access to docker without sudo

    - role: artis3n.tailscale

  post_tasks:

  # Configure the firewall

  - name: enable firewalld
    ansible.builtin.systemd:
      name: firewalld
      enabled: true

  - name: disable dhcpv6 in public zone
    ansible.posix.firewalld:
      service: dhcpv6-client
      permanent: true
      state: disabled
      zone: public

  - name: allow ssh in public zone
    ansible.posix.firewalld:
      port: "{{ ssh_port }}/tcp"
      state: enabled
      permanent: true
      zone: public

  - name: allow mosh in public zone
    ansible.posix.firewalld:
      service: mosh
      state: enabled
      permanent: true
      zone: public

  - name: add tailscale interface into trusted zone
    ansible.posix.firewalld:
      interface: tailscale0
      zone: trusted
      permanent: true
      state: enabled

  - name: allow ssh in external zone
    ansible.posix.firewalld:
      port: "{{ ssh_port }}/tcp"
      state: enabled
      permanent: true
      zone: external

  - name: allow mosh in external zone
    ansible.posix.firewalld:
      service: mosh
      state: enabled
      permanent: true
      zone: external

  - name: allow https in external zone
    ansible.posix.firewalld:
      service: https
      state: enabled
      permanent: true
      zone: external

  - name: enable knockd
    ansible.builtin.systemd:
      name: knockd
      enabled: true

  - name: create directory for cron scripts
    ansible.builtin.file:
      path: /usr/local/cron
      state: directory

  - name: copy cloudflare zone script to the server
    ansible.builtin.copy:
      src: configs/cloudshell/cloudflare/firewalld.allow-cloudflare.sh
      dest: /usr/local/cron/firewalld.allow-cloudflare.sh
      mode: '700'

  - name: run script to build cloudflare zone
    ansible.builtin.command: /usr/local/cron/firewalld.allow-cloudflare.sh

  # Set up root configs

  - name: copy netplan config
    ansible.builtin.copy:
      src: configs/cloudshell/netplan/01-netcfg.yaml
      dest: /etc/netplan/01-netcfg.yaml

  - name: Copy ssh config
    ansible.builtin.copy:
      src: configs/cloudshell/ssh/sshd_config
      dest: /etc/ssh/sshd_config

  - name: copy root bashrc
    ansible.builtin.copy:
      src: configs/cloudshell/root/.bashrc
      dest: /root/.bashrc

  - name: copy root gitconfig
    ansible.builtin.copy:
      src: configs/cloudshell/root/.gitconfig
      dest: /root/.gitconfig

  - name: copy root private key
    ansible.builtin.copy:
      src: configs/cloudshell/root/.ssh/id_ed25519
      dest: /root/.ssh/id_ed25519
      mode: '600'

  - name: copy root public key
    ansible.builtin.copy:
      src: configs/cloudshell/root/.ssh/id_ed25519.pub
      dest: /root/.ssh/id_ed25519.pub

  - name: copy known hosts for config repo
    ansible.builtin.copy:
      src: configs/cloudshell/root/.ssh/known_hosts
      dest: /root/.ssh/known_hosts

  - name: clone, reset, and checkout yadm
    ansible.builtin.shell: |
      yadm --yadm-dir /etc/yadm clone -w / "{{ csh_config_repo }}"
      yadm --yadm-dir /etc/yadm reset
      yadm --yadm-dir /etc/yadm checkout "/"

  # set up connor user

  - name: create .ssh directory and set permissions
    ansible.builtin.file:
      path: /home/connor/.ssh
      state: directory
      owner: connor
      group: connor
      mode: '700'

  - name: copy connor user authorized_keys
    ansible.builtin.copy:
      src: configs/cloudshell/connor/.ssh/authorized_keys
      dest: /home/connor/.ssh/authorized_keys
      owner: connor
      group: connor
      mode: '600'

  - name: copy connor user known_hosts
    ansible.builtin.copy:
      src: configs/cloudshell/connor/.ssh/known_hosts
      dest: /home/connor/.ssh/known_hosts
      owner: connor
      group: connor
      mode: '600'

  - name: copy connor user ssh public key
    ansible.builtin.copy:
      src: configs/cloudshell/connor/.ssh/id_ed25519.pub
      dest: /home/connor/.ssh/id_ed25519.pub
      owner: connor
      group: connor
      mode: '644'

  - name: copy connor user ssh private key
    ansible.builtin.copy:
      src: configs/cloudshell/connor/.ssh/id_ed25519
      dest: /home/connor/.ssh/id_ed25519
      owner: connor
      group: connor
      mode: '600'

  - name: clone, reset, and checkout yadm
    become: true
    become_user: connor
    become_method: su
    become_flags: '--login'
    vars:
      ansible_become_pass: "{{ csh_user_password }}"
    ansible.builtin.shell: |
      yadm clone "{{ dotfiles_repo }}"
      yadm checkout

  - name: Reboot server
    ansible.builtin.command: reboot
    ignore_errors: true
